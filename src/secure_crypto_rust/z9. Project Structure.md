# **production-grade re-organization**

* keeps Rust **fast to compile & test**
* keeps PyO3 **isolated**
* gives us a **clean public Rust API**
* gives Python a **stable binding layer**
* supports **v1 + v2 side-by-side**
* avoids rebuilding Python when testing Rust

The **final structure + concrete `lib.rs` layouts**.

---

## 1ï¸âƒ£ Correct high-level architecture (non-negotiable)

We have **two Rust crates** in a workspace:

```bash
src/secure_crypto_rust
â”œâ”€â”€ Cargo.toml              # workspace
â”‚
â”œâ”€â”€ core/            # ğŸš€ pure Rust (FAST)
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ compression/
â”‚       â”œâ”€â”€ telemetry/
â”‚       â”œâ”€â”€ stream_v1/
â”‚       â”œâ”€â”€ stream_v2/
â”‚       â”œâ”€â”€ headers/
â”‚       â”œâ”€â”€ framing/
â”‚       â”œâ”€â”€ crypto/
â”‚       â”œâ”€â”€ constants.rs
â”‚       â”œâ”€â”€ types.rs
â”‚       â””â”€â”€ lib.rs
â”‚
â””â”€â”€ python/          # ğŸ PyO3 bindings (SLOW, isolated)
    â”œâ”€â”€ Cargo.toml
    â””â”€â”€ src/
        â”œâ”€â”€ lib.rs
        â”œâ”€â”€ ffi/
        â”‚   â”œâ”€â”€ mod.rs
        â”‚   â”œâ”€â”€ constants.rs
        â”‚   â”œâ”€â”€ types.rs
        â”‚   â””â”€â”€ tests.rs
```

ğŸ‘‰ **Rule:**
`core` must compile **without PyO3 installed**.

---

## 5ï¸âƒ£ Why this solves pain points

### â± Compile time

* `cargo test -p crypto-core` â†’ **seconds**
* No PyO3 rebuilds
* No Python headers

### ğŸ§  Parallelism

* `stream_v2` uses **OS threads + crossbeam**
* No async illusions
* No GIL involvement

### ğŸ§ª Testing

```bash
cd src/secure_crypto_rust
cargo test -p crypto-core
```

Python not involved at all.

---

## 2ï¸âƒ£ `core/src/lib.rs` (PURE RUST)

```rust

```

### Why this is correct

* **No PyO3**
* **No Python**
* `cargo test` is now **fast**
* v1 and v2 coexist cleanly

---

## 3ï¸âƒ£ `python/src/lib.rs` (PyO3 ONLY)

This replaces mixed PyO3 `lib.rs`.

```rust
//! crypto-python
//!
//! Python bindings for crypto-core (PyO3).

use pyo3::prelude::*;

mod ffi;

/// Python module entry point
#[pymodule]
fn rust_crypto(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    ffi::register(py, m)?;
    Ok(())
}
```

---

## 4ï¸âƒ£ `python/src/ffi/mod.rs`

This is where **everything Python-facing lives**.

```rust
use pyo3::prelude::*;

mod adapters_sync;
mod adapters_async;
mod params;
mod enums;
mod constants;
mod tests;

pub fn register(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    adapters_sync::register(py, m)?;
    adapters_async::register(py, m)?;
    params::register(py, m)?;
    enums::register(py, m)?;
    constants::register(py, m)?;
    Ok(())
}
```

---

## 5ï¸âƒ£ PyO3 adapters depend on crypto-core (cleanly)

Example: `adapters_sync.rs`

```rust
use pyo3::prelude::*;
use crypto_core::prelude::*;

#[pyfunction]
fn encrypt_stream_v2_py(
    input: PyObject,
    output: PyObject,
    params: EncryptParams,
    parallelism: ParallelismProfile,
) -> PyResult<TelemetrySnapshot> {
    let input = InputSource::from_py(input)?;
    let output = OutputSink::from_py(output)?;

    encrypt_stream_v2(
        input,
        output,
        &params.master_key,
        params,
        parallelism,
    ).map_err(|e| e.into())
}

pub fn register(_py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(encrypt_stream_v2_py, m)?)?;
    Ok(())
}
```

---

## 6ï¸âƒ£ What we gain immediately

### ğŸš€ Rust testing

```bash
cd core
cargo test
```

* no Python
* no PyO3
* no maturin
* fast incremental builds

### ğŸ Python testing

```bash
cd python
maturin develop
pytest
```

Only when needed.

---

## ğŸ”‘ Separation of Concerns

* **src/crypto/digest.rs**  

  Should remain focused on **cryptographic digest operations only**:
  * Digest updates (`update_frame`, `finalize`)  
  * Serializable state export/import (checkpointing support)  
  * Verification helpers (`SegmentDigestVerifier`)  

ğŸ‘‰ This keeps digest.rs aligned with its domain: *crypto state + correctness*.

---

## ğŸ“¦ Suggested New Modules

1. **src/recovery/checkpoint.rs**
   * Defines `SegmentCheckpoint` and `DecryptCheckpoint` structs.  
   * Wraps serialized digest state + segment metadata.  
   * Provides helpers for exporting/importing resume points.  

2. **src/log/unified.rs**  
   * Owns `UnifiedEntry` enum (`Scheduler`, `Encrypt`, `Decrypt`).  
   * `LogManager` for append, rotate, replay.  
   * Compaction logic (`compact_unified_log`).  

3. **src/scheduler/policy.rs**  
   * `HybridCompactionPolicy` struct.  
   * `should_compact`, `mark_compacted`.  
   * Scheduler cycle runner (`spawn_scheduler_cycle`).  

4. **src/recovery/bootstrap.rs**  
   * `load_unified_log` + replay logic.  
   * Restores checkpoints + scheduler state.  
   * Resumes workers from `DigestResumePoint`.  

---

## ğŸ“‚ Directory Layout

```bash
src/
 â”œâ”€â”€ crypto/
 â”‚    â”œâ”€â”€ digest.rs        # digest updates + verification
 â”‚    â””â”€â”€ framing.rs       # encode/decode frames
 â”œâ”€â”€ workers/
 â”‚    â”œâ”€â”€ encrypt.rs       # EncryptSegmentWorker
 â”‚    â””â”€â”€ decrypt.rs       # DecryptSegmentWorker
 â”œâ”€â”€ recovery/
 â”‚    â”œâ”€â”€ checkpoint.rs    # checkpoint structs + helpers
 â”‚    â””â”€â”€ bootstrap.rs     # recovery replay + resume
 â”œâ”€â”€ log/
 â”‚    â””â”€â”€ unified.rs       # unified log manager + compaction
 â”œâ”€â”€ scheduler/
 â”‚    â””â”€â”€ policy.rs        # compaction policy + cycle
 â””â”€â”€ pipeline.rs           # orchestrator for segmentation + workers
```

---

## ğŸš€ Why This Split Works

* **digest.rs stays pure**: only crypto state + correctness.  
* **checkpoint.rs bridges crypto â†’ persistence**: digest state + segment metadata.  
* **unified.rs owns durability**: log append, rotation, compaction.  
* **policy.rs owns scheduling**: compaction triggers + injection.  
* **bootstrap.rs owns recovery**: replay + resume.  

This way, each module has a **single responsibility**, and we avoid coupling crypto logic with persistence or scheduling.

---
