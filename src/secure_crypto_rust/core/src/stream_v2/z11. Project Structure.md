# **Production-grade `stream_v2` project layout**

This layout is **deliberate**:

* minimal compile blast radius
* clean dependency direction
* testability without PyO3 / Tokio
* zero circular imports

---

## ğŸ“‚ `src/stream_v2/` â€” **Final Layout**

```bash
src/stream_v2/
â”‚
â”œâ”€â”€ mod.rs                    # Public faÃ§ade + re-exports
â”‚
â”œâ”€â”€ core.rs                   # encrypt_stream_v2 / decrypt_stream_v2
â”‚                             # (stable, public API)
â”‚
â”œâ”€â”€ io.rs                     # InputSource / OutputSink
â”‚                             # ordered writer / reader normalization
â”‚
â”œâ”€â”€ pipeline.rs               # Thread-pool wiring (no crypto)
â”‚
â”œâ”€â”€ segment_worker/           # SEGMENT = unit of parallelism
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ types.rs              # SegmentInput / EncryptedSegment / DecryptedSegment
â”‚   â”œâ”€â”€ crypto.rs             # SegmentCryptoContext (keys, header, nonce policy)
â”‚   â”œâ”€â”€ encrypt.rs            # EncryptSegmentWorker
â”‚   â”œâ”€â”€ decrypt.rs            # DecryptSegmentWorker
â”‚   â””â”€â”€ tests.rs              # segment worker tests (FAST)
â”‚
â”œâ”€â”€ frame_worker/             # FRAME = unit inside segment
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ types.rs              # FrameInput / FrameOutput
â”‚   â”œâ”€â”€ encrypt.rs            # EncryptFrameWorker
â”‚   â”œâ”€â”€ decrypt.rs            # DecryptFrameWorker
â”‚   â””â”€â”€ tests.rs              # frame-level tests
â”‚
â”œâ”€â”€ framing/                  # Wire format (NO CRYPTO)
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ types.rs              # FrameHeader / FrameRecord / FrameError
â”‚   â”œâ”€â”€ encode.rs
â”‚   â”œâ”€â”€ decode.rs
â”‚   â””â”€â”€ tests.rs              # framing invariants
â”‚
â””â”€â”€ tests/
    â””â”€â”€ roundtrip.rs          # Full v2 encrypt â†’ decrypt (single thread)
```

---

## ğŸ§­ Dependency Direction (STREAM_V2)

```text
headers
   â†‘
crypto
   â†‘
stream_v2
```

## ğŸ§­ Dependency Direction (CRITICAL)

```text
framing
   â†‘
frame_worker
   â†‘
segment_worker
   â†‘
pipeline
   â†‘
core
```

âœ” **Never inverted**
âœ” **No shared mutable state**
âœ” **Crypto only appears at frame/segment worker level**

---

## ğŸ“¦ `mod.rs` (example)

```rust
// src/stream_v2/mod.rs

pub mod core;
pub mod io;
pub mod pipeline;

pub mod framing;
pub mod frame_worker;
pub mod segment_worker;

pub use core::{encrypt_stream_v2, decrypt_stream_v2};
```

---

## ğŸ” Segment Worker Responsibilities

| File         | Responsibility                 |
| ------------ | ------------------------------ |
| `types.rs`   | Pure data structures           |
| `crypto.rs`  | Key derivation, nonce strategy |
| `encrypt.rs` | Segment â†’ encrypted wire       |
| `decrypt.rs` | Wire â†’ plaintext frames        |
| `tests.rs`   | Deterministic correctness      |

No IO.
No threads.
No channels.

---

## ğŸ§ª Why This Layout Compiles Fast

* Tests donâ€™t pull in:

  * PyO3
  * Tokio
  * async
* `segment_worker/tests.rs` touches **<15 files**
* `cargo test segment_worker` is seconds after first build

---

## ğŸ§  Why This Is the *Correct* Architecture

This matches **industrial streaming engines**:

| System      | Unit             |
| ----------- | ---------------- |
| NVMe        | submission queue |
| Kafka       | batch            |
| RocksDB     | SST block        |
| Our system  | **segment**      |

We are **not guessing** â€” weâ€™re converging on proven design.

---

## Current Situation Analysis (SegmentWorker::run_v1)

We have **two levels of workers**:

1. **Segment workers** (coordinators) - manage entire segments
2. **Frame workers** (workers) - process individual frames in parallel

And we're spawning threads with `thread::spawn()`, which **doesn't return errors** - threads that panic just terminate silently.

## The Problem with Current Design (SegmentWorker::run_v1)

```rust
thread::spawn(move || {
    // If anything panics here, the error is lost!
    verifier.finalize().expect("DIGEST MISMATCH"); // âŒ Panic disappears into void
});
```

The test only detected the failure because we checked for channel disconnection. But we have no way to get the **actual error message** or **error type** back to the caller.

## Best Practice: Structured Error Handling

Here's the better approach:

### 1. **Frame Workers**: Return Results (No Panics)

Frame workers should **never panic** - they should always return `Result`:

```rust
pub fn run(
    self,
    rx: Receiver<FrameInput>,
    tx: Sender<Result<EncryptedFrame, FrameWorkerError>>,
) {
    std::thread::spawn(move || {
        while let Ok(input) = rx.recv() {
            let result = self.encrypt_frame(input); // Returns Result
            
            // Always send result, never panic
            if tx.send(result).is_err() {
                return; // Coordinator dropped rx, exit cleanly
            }
        }
    });
}
```

**Why?** Frame workers are "leaf workers" - they should report errors, not decide how to handle them.

### 2. **Segment Workers**: Structured Error Propagation

Segment workers should collect errors and return them via a `Result` channel:

```rust
pub fn run(
    self,
    rx: Receiver<Arc<Vec<u8>>>,
    tx: Sender<Result<DecryptedSegment, SegmentWorkerError>>, // âœ… Result type
    resume: Option<SegmentResumePoint>,
) {
    let crypto = self.crypto.clone();
    let log_manager = self.log_manager.clone();

    thread::spawn(move || {
        // Process segments, sending Result for each
        while let Ok(segment_wire) = rx.recv() {
            let result = process_segment(&segment_wire, &crypto, &log_manager, &resume);
            
            // Send result (Ok or Err)
            if tx.send(result).is_err() {
                return; // Receiver dropped, exit
            }
        }
    });
}

// Extract processing logic into a function that returns Result
fn process_segment(
    segment_wire: &[u8],
    crypto: &SegmentCryptoContext,
    log_manager: &Arc<AsyncLogManager>,
    resume: &Option<SegmentResumePoint>,
) -> Result<DecryptedSegment, SegmentWorkerError> {
    // ... setup code ...
    
    // Collect frames
    for _ in 0..frame_count {
        let frame_result = out_rx.recv()
            .map_err(|_| SegmentWorkerError::FrameWorkerDisconnected)?;
        
        let frame = frame_result
            .map_err(SegmentWorkerError::FrameDecryptionFailed)?;
        
        // ... process frame ...
    }
    
    // Verify digest - return error instead of panic
    verifier.finalize()
        .map_err(SegmentWorkerError::DigestMismatch)?;
    
    Ok(DecryptedSegment {
        segment_index,
        frames: plaintext_out,
        telemetry,
    })
}
```

### 3. **Define Comprehensive Error Types**

```rust
#[derive(Debug, thiserror::Error)]
pub enum SegmentWorkerError {
    #[error("Frame worker disconnected unexpectedly")]
    FrameWorkerDisconnected,
    
    #[error("Frame decryption failed: {0}")]
    FrameDecryptionFailed(#[from] FrameWorkerError),
    
    #[error("Segment digest mismatch - data corruption or tampering detected")]
    DigestMismatch(#[from] DigestError),
    
    #[error("Segment framing error: {0}")]
    FramingError(#[from] FrameError),
    
    #[error("Invalid segment structure")]
    InvalidSegment,
    
    #[error("Checkpoint persistence failed: {0}")]
    CheckpointError(String),
}

#[derive(Debug, thiserror::Error)]
pub enum FrameWorkerError {
    #[error("AEAD decryption failed: {0}")]
    Crypto(#[from] CryptoError),
    
    #[error("Frame parsing error: {0}")]
    FrameParsing(#[from] FrameError),
    
    #[error("Invalid frame header")]
    InvalidHeader,
}
```

## Recommended Architecture

```rust
// High-level API
pub struct DecryptPipeline {
    segment_worker: DecryptSegmentWorker,
    // ...
}

impl DecryptPipeline {
    pub fn process_stream(
        &self,
        input: Receiver<Arc<Vec<u8>>>,
    ) -> Receiver<Result<DecryptedSegment, SegmentWorkerError>> {
        let (tx, rx) = unbounded();
        self.segment_worker.run(input, tx, None);
        rx
    }
}

// Usage
let results = pipeline.process_stream(input_rx);

for result in results.iter() {
    match result {
        Ok(segment) => {
            // Process decrypted segment
            println!("Decrypted segment {}", segment.segment_index);
        }
        Err(SegmentWorkerError::DigestMismatch(e)) => {
            eprintln!("CRITICAL: Data tampering detected: {}", e);
            // Decide: abort? skip segment? alert user?
        }
        Err(SegmentWorkerError::FrameDecryptionFailed(e)) => {
            eprintln!("Frame decryption error: {}", e);
            // Maybe retry? Log and continue?
        }
        Err(e) => {
            eprintln!("Segment processing error: {}", e);
        }
    }
}
```

## When to Panic vs Return Error?

| Situation | Action | Reason |
|-----------|--------|--------|
| Frame AEAD failure | Return `Err` | Expected failure mode (corrupted data) |
| Digest mismatch | Return `Err` | Expected failure mode (tampering) |
| Invalid frame format | Return `Err` | Expected failure mode (malformed input) |
| Channel send failure | Return early | Receiver dropped, clean shutdown |
| Worker pool init failure | **Panic** (in constructor) | Programming error, can't proceed |
| Crypto primitives unavailable | **Panic** (in constructor) | System configuration error |
| Internal logic bugs | `debug_assert!` or panic | Should never happen, developer error |

## Updated Test

```rust
#[test]
fn test_digest_mismatch_failure() {
    let (ctx, log) = setup_test_context(DigestAlg::Sha256);
    let (mid_tx, mid_rx) = channel::unbounded();
    let (out_tx, out_rx) = channel::unbounded();

    let dec_worker = DecryptSegmentWorker::new(ctx.clone(), log.clone());
    dec_worker.run(mid_rx, out_tx, None);

    let corrupted_wire = generate_tampered_segment(&ctx, &log);
    mid_tx.send(Arc::new(corrupted_wire)).unwrap();
    drop(mid_tx);

    // Now we get a proper error!
    match out_rx.recv_timeout(Duration::from_secs(2)) {
        Ok(Err(SegmentWorkerError::DigestMismatch(_))) => {
            println!("âœ… SUCCESS: Digest mismatch properly detected");
        }
        Ok(Err(e)) => panic!("âŒ Wrong error type: {:?}", e),
        Ok(Ok(_)) => panic!("âŒ FAIL: Worker accepted bad data"),
        Err(_) => panic!("âŒ FAIL: No response from worker"),
    }
}
```

## Migration Strategy

1. **Phase 1**: Update frame workers to return `Result` (already done âœ…)
2. **Phase 2**: Extract segment processing into `process_segment()` function that returns `Result`
3. **Phase 3**: Change segment worker's output channel to `Sender<Result<T, E>>`
4. **Phase 4**: Update all tests to expect `Result` types
5. **Phase 5**: Remove all `.expect()` calls, replace with `?` operator

## Summary

**Best practice**:

* âœ… **Frame workers**: Always return `Result`, never panic
* âœ… **Segment workers**: Return `Result` via channel, catch and convert errors
* âŒ **Avoid**: `.expect()` in worker threads (errors get lost)
* âœ… **Panic only for**: Initialization failures, programming errors, `debug_assert!`

This gives us:

* **Structured error handling** - callers can decide how to handle each error type
* **Better debugging** - full error context preserved
* **Graceful degradation** - can skip bad segments, retry, or log errors
* **Testability** - can assert specific error types

---
